---

marp: true
theme: marping
paginate: false
title: Taller de Agentes con MCP
description: Introducci√≥n, implementaci√≥n pr√°ctica y observabilidad de MCP
header: 'Tech Day June 25'
footer: 'Taller de Agentes con MCP'
--------------------------------------------------------------------------
<!-- _class: portrait -->
# Taller de Agentes con MCP

## Objetivos

* Introducir el concepto de MCP.
* Implementar herramientas y agentes con Java, Python y JavaScript.
* Aprender y aplicar buenas pr√°cticas.

---

## üíª Requisitos:

- Port√°til personal con 16 GB de RAM o m√°s (mejor si tiene GPU)
- Ollama instalado: https://ollama.com/download
- Cargar y probar el modelo Qwen 2.5:  
  ```$ ollama run qwen2.5```
- Tener un IDE configurado para ejecutar proyectos Java, Node.js o Python (seg√∫n tu elecci√≥n)
- Instalar Node.js, incluidos los que hag√°is el taller en Java y Python, se necesita para mcpinspector:  
  ```https://nodejs.org/es/download```

---

## üóìÔ∏è Agenda

1. Introducci√≥n
2. Crear primera herramienta MCP
‚òïÔ∏è Descanso 5" ‚è±Ô∏è 
3. Crear primer agente usando MCP
4. Crear y usar varios MCP, diferentes protocolos y c√≥mo consumirlos
5. El futuro de MCP
‚òïÔ∏è Descanso 5" ‚è±Ô∏è 
6. Route to production!
7. Preguntas y Cierre ‚ùì
Apendices, Recursos y Tips

---

<!-- _class: lead -->

# 1. Introducci√≥n

---

## ¬øQu√© es MCP?

* **Model Context Protocol**
* Define c√≥mo se comunican los agentes con modelos, recursos y herramientas.
* Inspirado en arquitecturas de microservicios y flujos de agentes LLM.
* Modular, extensible y agn√≥stico del lenguaje.

---

## ¬øPor qu√© MCP?

* Modularidad y separaci√≥n de responsabilidades
* Protocolo unificado para prompts, recursos y herramientas
* Facilita depuraci√≥n, trazabilidad y despliegue
* Habilita la interoperabilidad entre diferentes tecnolog√≠as

---

## Implementaciones MCP

* Java: Spring Boot
* Node.js: Express + mcp-server
* Python: FastAPI + mcp-lib

üõ†Ô∏è **Actividad**: Clonar proyecto base y ejecutar un ejemplo simple en cada lenguaje

> ![Github](github.png) **paso0**

---

## Introducci√≥n a MCP

* MCP soporta distintos mecanismos de transporte:

  * `STDIO`: para herramientas CLI
  * `SSE`: para streaming HTTP
  * `Streamable HTTP`: interacci√≥n continua

---
<!-- _class: lead -->

# 2. Crear primera herramienta MCP

---

## Funci√≥n de llamada a AEMET

* C√≥digo ejecutable que el agente puede usar
* Pueden ser funciones locales o llamadas externas

üß™ **Demo**: A√±adir una funci√≥n que le pases el c√≥digo AEMET y devuelva la respuesta de AEMET cruda

> ![Github](github.png) **paso1**

--- 

## Funci√≥n de llamada a AEMET

1. Pedir apikey aqu√≠: https://opendata.aemet.es/centrodedescargas/altaUsuario
2. Llamada a usar /api/prediccion/especifica/municipio/diaria/{municipio}?api_key={apikeyaemet}
3. Municipio de ejemplo: Las Rozas: 28127 o buscar uno en https://www.ine.es/daco/daco42/codmun/diccionario24.xlsx
4. Respuesta JSON con urls, llamar a la url respuesta.datos
5. Segunda llamada ya tiene los datos del tiempo de verdad
requests.get(data.get("datos"))

 Swagger: https://opendata.aemet.es/dist/index.html?#/predicciones-especificas/Predicci%C3%B3n%20por%20municipios%20diaria.%20Tiempo%20actual

--- 

## Crear servidor MCP y convertir la funci√≥n en herramienta

üõ†Ô∏è **Actividad**: A√±adir una herramienta que use la funci√≥n anterior

> ![Github](github.png) **paso2**

---

## Probar nuestra herramienta: mcp-inspector

```$ npx @modelcontextprotocol/inspector```

* Conectamos a la herramienta usando comando y argumentos
* Probamos la herramienta, usamos 28127 para probar

üõ†Ô∏è **Actividad**: Instalar y usar mcp-inspector con el agente anterior

> ![Github](github.png) **paso2**

---

<!-- _class: lead -->

# ‚òïÔ∏è Descanso 5" ‚è±Ô∏è 

---

<!-- _class: lead -->

# 3. Crear primer agente usando MCP

---

## Crear un agente b√°sico. Patrones

  * **Reasoning and Acting (ReAct)**: Respuesta inmediata a est√≠mulos.
  * **Workflow**: Secuencias predefinidas.
  * **Planificador/Ejecutor**: Decisi√≥n separada de ejecuci√≥n.
  * **Supervisor**: Monitoreo y correcci√≥n.
  * **Colaborativo**: Coordinaci√≥n con otros agentes o humanos.
  * **H√≠brido**: Combinaci√≥n de enfoques.

üõ†Ô∏è **Actividad**: Creamos un agente react, que es el m√°s sencillo de desarrollar, y que llame a la herramienta anterior.

> ![Github](github.png) **paso3**

---

## El tama√±o del prompt

* ¬øQu√© pasa con el agente, no funciona?
* Si superamos los 32K tokens que admite Qwen 2.5, ¬øqu√© hace el agente? 
```spoiler, se queda con los √∫ltimos 32k.```
* ¬øC√≥mo podemos solucionar esto?

üõ†Ô∏è **Actividad**: Vamos a hacer una poda a la respuesta de AEMET. ¬øMejoran las respuestas? ¬øY el tiempo de ejecuci√≥n?

> ![Github](github.png) **paso4**

---

<!-- _class: lead -->

# 4. Crear y usar varios MCP, diferentes protocolos y c√≥mo consumirlos

---

## Crear una tool de calendario

* Hacer lo mismo pero llamando a un calendario
* Pista: usar librer√≠a para entender CalDAV
* Exponerla como REST en vez de STDIO

üõ†Ô∏è **Actividad**: A√±adir una funci√≥n que llame a un calendario ICS y devuelva un JSON con tus eventos

CALENDAR_URL=https://calendar.google.com/calendar/ical/0f7e8a7191ceda59262822a5fbed28f9dedae882137d0af94eddbbbdae292bd4%40group.calendar.google.com/public/basic.ics

> ![Github](github.png) **paso5**

---

## Usar las dos tools desde el agente

* Actualizamos el agente para poder hacer consultas compuestas

üõ†Ô∏è **Actividad**: Haz que tu agente use las dos herramientas en una sola consulta

> ![Github](github.png) **paso6**

üí° Si os da tiempo, llamad a los MCP de otro compa√±ero en otro lenguaje desde vuestro agente.

---

<!-- _class: lead -->

# 5. El futuro de MCP

---

## @resources

* Variables globales: credenciales, configuraciones‚Ä¶
* √ötiles para separar l√≥gica de entorno
* A√∫n no est√°n disponibles en casi ning√∫n framework
* LangGraph permite cargar @resources, pero hay que integrarlos manualmente en los agentes

üìüÔ∏è **Demo**: Definir el listado de c√≥digos de AEMET y que sea el agente quien busque el c√≥digo de tu localidad

---

## @prompts y @roots

* Prompts reutilizables por el agente
* Dise√±o modular de tareas
* Define el flujo principal del agente
* Composici√≥n de herramientas, recursos y prompts
* No est√°n disponibles en la mayor√≠a de frameworks
* LangGraph permite cargar @prompts, no @roots

üìüÔ∏è **Demo**: Para qu√© usamos un prompt
üìüÔ∏è **Demo**: Crear un MCP que liste archivos de una carpeta

---
<!-- _class: lead -->

# ‚òïÔ∏è Descanso 5" ‚è±Ô∏è 

---

<!-- _class: lead -->

# 6. Route to production!

---

## Route to Production

- **Objetivos Claros:** Definir el caso de uso y metas.
- **Elecci√≥n del Enfoque:** Agentes reactivos vs. workflows vs ...
- **Pruebas Automatizadas:** Establecer un plan robusto de pruebas (regresi√≥n y progresi√≥n).
- **Monitoreo y Logging:** Implementar herramientas desde el inicio.
- **Escalabilidad y Seguridad:** Dise√±ar arquitectura escalable y segura.
- **Costes:** Estimar los costes de creaci√≥n, run y mantenimiento.

---

## Comparaci√≥n de Enfoques: Reactivos vs. Workflows

**Reactivos:**
- **Ventajas:** Flexibilidad, adaptaci√≥n r√°pida.
- **Desventajas:** Complejidad en pruebas y mantenimiento.

**Workflows:**
- **Ventajas:** Control, previsibilidad, facilidad de depuraci√≥n.
- **Desventajas:** Menor flexibilidad ante cambios.

&nbsp;

üëÆ‚Äç‚ôÇÔ∏è ¬°El caso de uso manda!

--- 

## Prompts cuidados y herramientas afinadas

- **Prompt Engineering:** Es fundamental dise√±ar un buen prompt: como hemos visto, aunque tengamos los mejores datos, si el prompt es malo, los resultados ser√°n pobres o irrelevantes. El prompt es la clave para obtener respuestas √∫tiles y precisas.

- **Preparar las Respuestas de las Herramientas:** No basta con devolver todo el contenido "a lo bruto" y dejar que el agente lo gestione. Es mucho mejor limpiar, preparar y formatear las respuestas desde la propia herramienta. Todo lo que se pueda hacer con c√≥digo para facilitar el trabajo al agente, ¬°hazlo! As√≠ se obtienen agentes m√°s eficientes y resultados m√°s √∫tiles.

---

## Pruebas y Actualizaciones

- **Deterministas:** Pruebas de regresi√≥n localizadas, validaci√≥n m√°s sencilla.
- **Reactivos:** Pruebas de regresi√≥n complejas, validaci√≥n exhaustiva de nuevos comportamientos.
- **Actualizaciones:** Estrategias para minimizar impactos y asegurar funcionalidad.

---

## Seguridad y Guardarra√≠les

- **Autenticaci√≥n y Autorizaci√≥n:** Implementar medidas de seguridad en ejecuci√≥n de herramientas
- **Guardarra√≠les:** Validaci√≥n de entradas y salidas. Establecer l√≠mites, evitar acciones no deseadas, √©tica y enfoque de marca. Control de errores y respuestas maliciosas
- **Enfoque Reactivo:** Mayor atenci√≥n a la seguridad din√°mica y control de acceso en tiempo real.
- **Enfoque Workflow:** Mayor √©nfasis en la seguridad predefinida y validaci√≥n de flujos de trabajo.

---

## Observabilidad con Langfuse

* Trazas, logs, m√©tricas y anal√≠tica de ejecuci√≥n de agentes
* Visualizaci√≥n y debug / troubleshooting en tiempo real

üìüÔ∏è **Demo**:

1. Desplegar Langfuse con Docker
2. Instrumentar agente con Langfuse
3. Ver ejecuci√≥n desde el dashboard

---

## Buenas pr√°cticas

‚úÖ Separar planificaci√≥n de ejecuci√≥n suele ayudar, independientemente del patr√≥n usado  
‚úÖ Peque√±os agentes especializados, como en todo  
‚úÖ Pruebas e2e para validar, de componente para desarrollar, usa herramientas como mcp-inspector  
‚úÖ Observabilidad desde el inicio, usa herramientas como Langfuse

---

<!-- _class: lead -->

# 7. Preguntas‚ùì y Cierre!

---

## Recursos:

  * [modelcontextprotocol.io](https://modelcontextprotocol.io/)
  * [GitHub MCP](https://github.com/modelcontextprotocol)
  * [mcp-inspector](https://github.com/modelcontextprotocol/inspector)
  * [Langfuse](https://langfuse.com)
  * [Claude](https://claude.ai/login?returnTo=%2F%3F#features)
  * [Awesome MCP Servers](https://mcpservers.org/)

---

## Tips:

  * Si usais mcps para claude, casi todos los de [Awesome MCP Servers](https://mcpservers.org/), suelen tener config por variables de entorno, pero no usan dotenv, desde la config de langchain podeis pasar variables de entorno as√≠:

  ``` python
      "weather": {
        "command": "uv",
        "args": ["run", "python", "weather.py"],
        "transport": "stdio",
        "env":
          "AEMET_API_KEY": "eyJhbGciOiJI.....",
      },
  ```

---

## Ap√©ndice: listado de pasos y actividades

üõ†Ô∏è **Actividad paso0**: Clonar proyecto base y ejecutar un ejemplo simple en cada lenguaje
üõ†Ô∏è **Actividad paso1**: A√±adir una funci√≥n que le pases el c√≥digo AEMET y devuelva la respuesta de AEMET cruda
üõ†Ô∏è **Actividad paso2**: A√±adir una herramienta que use la funci√≥n anterior
üõ†Ô∏è **Actividad paso3**: Creamos un agente react, que es el m√°s sencillo de desarrollar, y que llame a la herramienta anterior.
üõ†Ô∏è **Actividad paso4**: Vamos a hacer una poda a la respuesta de AEMET. ¬øMejoran las respuestas? ¬øY el tiempo de ejecuci√≥n?
üõ†Ô∏è **Actividad paso5**: A√±adir una funci√≥n que llame a un calendario ICS y devuelva un JSON con tus eventos
üõ†Ô∏è **Actividad paso6**: Haz que tu agente use las dos herramientas en una sola consulta
üõ†Ô∏è **Demo paso7**: Uso de LangFuse

---

## Apendice: snippets Java

---

## Apendice: snippets Nodejs

---

## Apendice: snippets Python

